"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[613],{8434:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=t(5893),r=t(1151);const s={title:"IBC NameService Contract",sidebar_label:"IBC Contract (Part 3)",sidebar_position:8,slug:"/build/name-service-ibc-contract"},c="IBC Name Service Contract",i={id:"build-your-application/ibc-cosmwasm",title:"IBC NameService Contract",description:"You will build a new IBC contract with CosmWasm, enabling the same features we just built out in the IBC module. While this is a part 3 of the series, it can be done standalone as it requires a new chain. It is a similar concept to the previous parts 1 and 2, but with a smart contract focus instead of a chain.",source:"@site/versioned_docs/version-v0.50.x/02-build-your-application/09-ibc-cosmwasm.md",sourceDirName:"02-build-your-application",slug:"/build/name-service-ibc-contract",permalink:"/spawn/v0.50/build/name-service-ibc-contract",draft:!1,unlisted:!1,tags:[],version:"v0.50.x",sidebarPosition:8,frontMatter:{title:"IBC NameService Contract",sidebar_label:"IBC Contract (Part 3)",sidebar_position:8,slug:"/build/name-service-ibc-contract"},sidebar:"defaultSidebar",previous:{title:"IBC NameService (Part 2)",permalink:"/spawn/v0.50/build/name-service-ibc-module"},next:{title:"IBC Transfers",permalink:"/spawn/v0.50/demo/ibc"}},o={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Setup the Chain",id:"setup-the-chain",level:2},{value:"Build CosmWasm Contract",id:"build-cosmwasm-contract",level:2},{value:"Update Contract Dependencies",id:"update-contract-dependencies",level:2},{value:"Setup State",id:"setup-state",level:2},{value:"Setup Interactions",id:"setup-interactions",level:2},{value:"Contract Logic",id:"contract-logic",level:2},{value:"Create Transaction acknowledgement",id:"create-transaction-acknowledgement",level:2},{value:"Setup Errors",id:"setup-errors",level:2},{value:"IBC Specific Logic",id:"ibc-specific-logic",level:2},{value:"Build Contract From Source",id:"build-contract-from-source",level:2},{value:"Start the chains and connect",id:"start-the-chains-and-connect",level:3},{value:"Store the Contract on both chains",id:"store-the-contract-on-both-chains",level:3},{value:"Instantiate our Contract on both chains",id:"instantiate-our-contract-on-both-chains",level:3},{value:"Relayer connect",id:"relayer-connect",level:3},{value:"Verify channels",id:"verify-channels",level:2},{value:"Transaction interaction",id:"transaction-interaction",level:2},{value:"Verify data",id:"verify-data",level:3},{value:"Summary",id:"summary",level:2},{value:"What you Learned",id:"what-you-learned",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"ibc-name-service-contract",children:"IBC Name Service Contract"}),"\n",(0,a.jsxs)(n.p,{children:["You will build a new IBC contract with ",(0,a.jsx)(n.a,{href:"https://cosmwasm.com",children:"CosmWasm"}),", enabling the same features we just built out in the IBC module. While this is a part 3 of the series, it can be done standalone as it requires a new chain. It is a similar concept to the previous parts 1 and 2, but with a smart contract focus instead of a chain."]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/spawn/v0.50/install/system-setup",children:"System Setup"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/spawn/v0.50/install/install-spawn",children:"Install Spawn"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/spawn/v0.50/install/system-setup#cosmwasm",children:"Rust + CosmWasm"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"setup-the-chain",children:"Setup the Chain"}),"\n",(0,a.jsx)(n.p,{children:"Build a new blockchain with CosmWasm enabled."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"GITHUB_USERNAME=rollchains\n\nspawn new cwchain \\\n--consensus=proof-of-stake \\\n--bech32=roll \\\n--denom=uroll \\\n--bin=rolld \\\n--disabled=block-explorer \\\n--org=${GITHUB_USERNAME}\n\n# move into the chain directory\ncd cwchain\n\n# download latest dependencies\ngo mod tidy\n"})}),"\n",(0,a.jsx)(n.h2,{id:"build-cosmwasm-contract",children:"Build CosmWasm Contract"}),"\n",(0,a.jsxs)(n.p,{children:["CosmWasm has a template repository that is used to generate new contracts. A minimal contract will be built with the ",(0,a.jsx)(n.code,{children:"nameservice-contract"})," name provided on a ",(0,a.jsx)(n.a,{href:"https://github.com/CosmWasm/cw-template/commits/a2a169164324aa1b48ab76dd630f75f504e41d99/",children:"specific commit"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cargo generate --git https://github.com/CosmWasm/cw-template.git \\\n    --name nameservice-contract \\\n    --force-git-init \\\n    -d minimal=true --tag a2a169164324aa1b48ab76dd630f75f504e41d99\n"})}),"\n",(0,a.jsx)(n.p,{children:"Open the contract in your code editor now to begin adding the application logic."}),"\n",(0,a.jsx)(n.admonition,{title:"Info",type:"note",children:(0,a.jsxs)(n.p,{children:["It is useful to install code rust extensions like ",(0,a.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer",children:"rust-analyzer"})," and ",(0,a.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml",children:"even better toml"})," for an increased editing experience."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# open using vscode in the terminal\ncode nameservice-contract/\n"})}),"\n",(0,a.jsx)(n.h2,{id:"update-contract-dependencies",children:"Update Contract Dependencies"}),"\n",(0,a.jsxs)(n.p,{children:["This version of the CosmWasm template has some outdated versions. Update these in the ",(0,a.jsx)(n.code,{children:"Cargo.toml"}),' file and add the "ibc3" capability (for IBC support).']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",metastring:'title="Cargo.toml"',children:'[dependencies]\n# highlight-start\ncosmwasm-schema = "1.5.7"\ncosmwasm-std = { version = "1.5.7", features = [\n    # "cosmwasm_1_3",\n    "ibc3"\n] }\n# highlight-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"Update your local environment with the dependencies."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cargo update\n"})}),"\n",(0,a.jsx)(n.h2,{id:"setup-state",children:"Setup State"}),"\n",(0,a.jsx)(n.p,{children:"This Rust code defines the structure for a name service in a CosmWasm smart contract. It saves a map of all channels (outside chain connections) to a list of wallet address and their associated names."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/state.rs"',children:'// highlight-start\nuse std::collections::BTreeMap;\n\nuse cw_storage_plus::Map;\n\n// Pair the wallet address to the name a user provides.\npub type WalletMapping = BTreeMap<String, String>;\n\n/// create a new empty wallet mapping for a channel.\n/// useful if a channel is opened and we have no data yet\npub fn new_wallet_mapping() -> WalletMapping {\n    BTreeMap::new()\n}\n\n/// Name Service maps for each channel saved to a storage object\npub const NAME_SERVICE: Map<String, WalletMapping> = Map::new("nameservice");\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.h2,{id:"setup-interactions",children:"Setup Interactions"}),"\n",(0,a.jsx)(n.p,{children:'Now that the state is setup, focus on modeling the users interaction with the contract. Users should be able to set a name. This also requires an input for a "channel" since a contract could connect to multiple chains. It could be written in a way that a user could set it to all channels, but for simplicity, we will require a channel to be specified. Just as is set, a user should get the name with the same format: a channel and a wallet address. Then a new message type is added specifically for IBCExecution messages. This is the packet transfered over the network, between chains, and gives the ability to set a name elsewhere on its contract.'}),"\n",(0,a.jsx)(n.p,{children:"The contract will call the IBCExecuteMsg when a user runs the ExecuteMsg.SendName function. This indirectly generates the packet and submits it for the user."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/msg.rs"',children:"use cosmwasm_schema::{cw_serde, QueryResponses};\n\n#[cw_serde]\npub struct InstantiateMsg {}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    // highlight-next-line\n    SetName { channel: String, name: String },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    // highlight-start\n    #[returns(GetNameResponse)]\n    GetName { channel: String, wallet: String },\n    // highlight-end\n}\n\n// highlight-start\n#[cw_serde]\npub enum IbcExecuteMsg {\n    SetName { wallet: String, name: String },\n}\n\n#[cw_serde]\npub struct GetNameResponse {\n    pub name: String,\n}\n// highlight-end\n"})}),"\n",(0,a.jsx)(n.h2,{id:"contract-logic",children:"Contract Logic"}),"\n",(0,a.jsx)(n.p,{children:"Here are all the imports used in this. Replace your files top."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/contract.rs"',children:'// highlight-start\n#[cfg(not(feature = "library"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};\n\nuse crate::error::ContractError;\nuse crate::msg::{ExecuteMsg, IbcExecuteMsg, InstantiateMsg, QueryMsg};\n\nuse cosmwasm_std::{to_json_binary, IbcMsg, IbcTimeout, StdError};\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"Instantiate creates a new version of this contract that you control. Rather than being unimplemented, return a basic response saying it was Ok (successful) and add some extra logging metadata."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/contract.rs"',children:'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    // highlight-next-line\n    Ok(Response::new().add_attribute("method", "instantiate"))\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The ExecuteMsg::SetName method is allowed to be interacted from anyone. Just like instantiate we return a new Ok response. This time an add_message function is added. This will generate the packet as the user interacts, performing a new action from a previous action. This uses the IbcMsg::SendPacket built in type to create it for the user. Notice the data field includes the IbcExecuteMsg::SetName we defined before. This is transferred to the other version of this contract on another chain and processed."}),"\n",(0,a.jsx)(n.p,{children:"If the packet is not picked up by a relayer service provider within a few minutes, the packet will become void and stop attempting execution on the other chain's contract."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/contract.rs"',children:'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n    _deps: DepsMut,\n    // highlight-start\n    env: Env, // removes the underscore _\n    info: MessageInfo,\n    msg: ExecuteMsg,\n    // highlight-end\n) -> Result<Response, ContractError> {\n    // highlight-start\n    match msg {\n        ExecuteMsg::SetName { channel, name } => {\n            Ok(Response::new()\n                .add_attribute("method", "set_name")\n                .add_attribute("channel", channel.clone())\n                // outbound IBC message, where packet is then received on other chain\n                .add_message(IbcMsg::SendPacket {\n                    channel_id: channel,\n                    data: to_json_binary(&IbcExecuteMsg::SetName {\n                        name: name,\n                        wallet: info.sender.into_string(),\n                    })?,\n                    // default timeout of two minutes.\n                    timeout: IbcTimeout::with_timestamp(env.block.time.plus_seconds(120)),\n                }))\n        }\n    }\n    // highlight-end\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The users name is not set, but it is only useful if you can also get said data. Read from the ",(0,a.jsx)(n.code,{children:"NAME_SERVICE"})," storage Map defined in ",(0,a.jsx)(n.code,{children:"state.rs"}),". Using may load grabs the data if the channel has a name set. If no channel is found (no users have set a name from this chain), it returns an error to the user requesting. If a channel of pairs is found, it loads them and checks if the wallet address requested is set in it. If it is, return what the wallets name is set to. If the user with this wallet did not set a name, return an error."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/contract.rs"',children:'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    // highlight-start\n    match msg {\n        QueryMsg::GetName { channel, wallet } => {\n            crate::state::NAME_SERVICE\n                .may_load(deps.storage, channel.clone())\n                .and_then(|maybe_wallets| match maybe_wallets {\n                    Some(wallets) => match wallets.get(&wallet) {\n                        Some(wallet) => Ok(to_json_binary(&crate::msg::GetNameResponse {\n                            name: wallet.clone(),\n                        })?),\n                        None => Err(StdError::generic_err("No name set for wallet")),\n                    },\n                    None => Err(StdError::generic_err("Channel not found")),\n                })\n        }\n    }\n    // highlight-end\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The contract will receive a packet and must run logic to process it. This is called the ",(0,a.jsx)(n.code,{children:"try_set_name"})," method. It updates a given channel to include a new wallet. If the wallet already exists, it will overwrite the name. It then returns the users name back, or an error, for our future IBC logic to handle."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/contract.rs"',children:"// highlight-start\n/// called on IBC packet receive in other chain\npub fn try_set_name(\n    deps: DepsMut,\n    channel: String,\n    wallet: String,\n    name: String,\n) -> Result<String, StdError> {\n    crate::state::NAME_SERVICE.update(deps.storage, channel, |wallets| -> StdResult<_> {\n        let mut wallets = wallets.unwrap_or_default();\n        wallets.insert(wallet, name.clone());\n        Ok(wallets)\n    })?;\n    Ok(name)\n}\n// highlight-end\n"})}),"\n",(0,a.jsx)(n.h2,{id:"create-transaction-acknowledgement",children:"Create Transaction acknowledgement"}),"\n",(0,a.jsxs)(n.p,{children:["Create a new file, ",(0,a.jsx)(n.code,{children:"ack.rs"}),", to handle the IBC ACK (acknowledgement) messages. This just returns back to the user if their interaction was a success or an error."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"touch src/ack.rs\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/ack.rs"',children:'// highlight-start\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{to_json_binary, Binary};\n\n/// IBC ACK. See:\n/// https://github.com/cosmos/cosmos-sdk/blob/f999b1ff05a4db4a338a855713864497bedd4396/proto/ibc/core/channel/v1/channel.proto#L141-L147\n#[cw_serde]\npub enum Ack {\n    Result(Binary),\n    Error(String),\n}\n\npub fn make_ack_success() -> Binary {\n    let res = Ack::Result(b"1".into());\n    to_json_binary(&res).unwrap()\n}\n\npub fn make_ack_fail(err: String) -> Binary {\n    let res = Ack::Error(err);\n    to_json_binary(&res).unwrap()\n}\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"note",children:(0,a.jsx)(n.p,{children:"Rust has a lib.rs file that is the entry point for the Rust library. All files that are used must be mentioned here to have access to them."})}),"\n",(0,a.jsx)(n.p,{children:"Add the ack logic to the lib.rs so the application can use it."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/lib.rs"',children:"// highlight-next-line\npub mod ack;\npub mod contract;\n...\n\npub use crate::error::ContractError;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"setup-errors",children:"Setup Errors"}),"\n",(0,a.jsx)(n.p,{children:'If a relayer or contract try to connect to an unlike protocol, the InvalidVersion error will be returned to the attempted actor. This contract only supports 1 protocol version across networks because it must speak the same "language". If you speak english while another person speaks spanish, your interactions are incompatible. Contracts are like this too. They verify their protocol version in a format like "ics-20" or "ns-1" first to make sure they can communicate.'}),"\n",(0,a.jsx)(n.p,{children:"OrderedChannel is a type of flow control for network packets, or interactions. This tutorial uses unordered paths so any packet that times out or fails does not block future packets from going through. If a relayer tries to make this an ordered path, the contract returns this error to stop them from doing so."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/error.rs"',children:'use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ContractError {\n    #[error("{0}")]\n    Std(#[from] StdError),\n\n    #[error("Unauthorized")]\n    Unauthorized {},\n    // Add any other custom errors you like here.\n    // Look at https://docs.rs/thiserror/1.0.21/thiserror/ for details.\n\n    // highlight-start\n    #[error("invalid IBC channel version. Got ({actual}), expected ({expected})")]\n    InvalidVersion { actual: String, expected: String },\n\n    #[error("only unordered channels are supported")]\n    OrderedChannel {},\n    // highlight-end\n}\n\n// highlight-start\n// There is an IBC specific error that is never returned.\n#[derive(Error, Debug)]\npub enum Never {}\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.h2,{id:"ibc-specific-logic",children:"IBC Specific Logic"}),"\n",(0,a.jsxs)(n.p,{children:["Create a new file ",(0,a.jsx)(n.code,{children:"ibc.rs"}),". Add this to the lib.rs. This is where our core IBC logic will go."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"touch src/ibc.rs\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/lib.rs"',children:"// highlight-next-line\npub mod ibc;\npub mod ack;\npub mod contract;\nmod error;\npub mod helpers;\npub mod msg;\npub mod state;\n\npub use crate::error::ContractError;\n"})}),"\n",(0,a.jsx)(n.p,{children:'Place the following in the ibc.rs file. Import all the types needed, set the IBC version to "ns-1" to stand for "nameservice-1", and add the basic validation logic for the contract. You must ensure contracts that try to talk together are verified to work together. This is that logic.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/ibc.rs"',children:'// highlight-start\n#[cfg(not(feature = "library"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_json, DepsMut, Env, IbcBasicResponse, IbcChannel, IbcChannelCloseMsg,\n    IbcChannelConnectMsg, IbcChannelOpenMsg, IbcChannelOpenResponse, IbcOrder, IbcPacketAckMsg,\n    IbcPacketReceiveMsg, IbcPacketTimeoutMsg, IbcReceiveResponse,\n};\n\nuse crate::{\n    ack::{make_ack_fail, make_ack_success},\n    contract::try_set_name,\n    msg::IbcExecuteMsg,\n    state::NAME_SERVICE,\n    ContractError,\n};\n\npub const IBC_VERSION: &str = "ns-1";\n\npub fn validate_order_and_version(\n    channel: &IbcChannel,\n    counterparty_version: Option<&str>,\n) -> Result<(), ContractError> {\n    // We expect an unordered channel here. Ordered channels have the\n    // property that if a message is lost the entire channel will stop\n    // working until you start it again.\n    if channel.order != IbcOrder::Unordered {\n        return Err(ContractError::OrderedChannel {});\n    }\n\n    if channel.version != IBC_VERSION {\n        return Err(ContractError::InvalidVersion {\n            actual: channel.version.to_string(),\n            expected: IBC_VERSION.to_string(),\n        });\n    }\n\n    // Make sure that we\'re talking with a counterparty who speaks the\n    // same "protocol" as us.\n    //\n    // For a connection between chain A and chain B being established\n    // by chain A, chain B knows counterparty information during\n    // `OpenTry` and chain A knows counterparty information during\n    // `OpenAck`. We verify it when we have it but when we don\'t it\'s\n    // alright.\n    if let Some(counterparty_version) = counterparty_version {\n        if counterparty_version != IBC_VERSION {\n            return Err(ContractError::InvalidVersion {\n                actual: counterparty_version.to_string(),\n                expected: IBC_VERSION.to_string(),\n            });\n        }\n    }\n\n    Ok(())\n}\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"The contract verifies data on an attempted open of a new connection. Ensure the contracts talk the same protocol language, and that all the validation basic logic is connect. Then when a channel is closed, clear the data from storage for it. It is very rare you would want to close a channel."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/ibc.rs"',children:'// highlight-start\n/// Handles the `OpenInit` and `OpenTry` parts of the IBC handshake.\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn ibc_channel_open(\n    _deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelOpenMsg,\n) -> Result<IbcChannelOpenResponse, ContractError> {\n    validate_order_and_version(msg.channel(), msg.counterparty_version())?;\n    Ok(None)\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn ibc_channel_close(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelCloseMsg,\n) -> Result<IbcBasicResponse, ContractError> {\n    let channel = msg.channel().endpoint.channel_id.clone();\n    NAME_SERVICE.remove(deps.storage, channel.clone());\n    Ok(IbcBasicResponse::new()\n        .add_attribute("method", "ibc_channel_close")\n        .add_attribute("channel", channel))\n}\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"When a successful connection is made, the contract saves a new blank wallet mapping to the channel's unique id. 'channel-0' is the first. All  future connections are channel-1, channel-2, etc. This is the first step in the IBC process. The contract is now ready to receive packets once the handler logic is put in place on receive."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/ibc.rs"',children:'// highlight-start\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn ibc_channel_connect(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelConnectMsg,\n) -> Result<IbcBasicResponse, ContractError> {\n    validate_order_and_version(msg.channel(), msg.counterparty_version())?;\n\n    let channel = msg.channel().endpoint.channel_id.clone();\n    NAME_SERVICE.save(\n        deps.storage, channel.clone(), &crate::state::new_wallet_mapping(),\n    )?;\n\n    Ok(IbcBasicResponse::new()\n        .add_attribute("method", "ibc_channel_connect")\n        .add_attribute("channel_id", channel))\n}\n// highlight-end\n'})}),"\n",(0,a.jsxs)(n.p,{children:["ibc_packet_receive handles incoming packets from already connected networks. The packet is forwarded to this contract and processed in ",(0,a.jsx)(n.code,{children:"do_ibc_packet_receive"}),". It takes the channel and the packet data ",(0,a.jsx)(n.em,{children:"(the IbcMsg::SetName sent out from the ExecuteMsg earlier)"}),", and tries to set the name on a wallet for this channel. If successful, it returns an acknowledgment of success. If not, it returns an acknowledgment of failure. The user will see this in their log event output."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/ibc.rs"',children:'// highlight-start\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn ibc_packet_receive(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketReceiveMsg,\n) -> Result<IbcReceiveResponse, crate::error::Never> {\n    // Regardless of if our processing of this packet works we need to\n    // commit an ACK to the chain. As such, we wrap all handling logic\n    // in a septate function and on error write out an error ack.\n    match do_ibc_packet_receive(deps, msg) {\n        Ok(response) => Ok(response),\n        Err(error) => Ok(IbcReceiveResponse::new()\n            .add_attribute("method", "ibc_packet_receive")\n            .add_attribute("error", error.to_string())\n            .set_ack(make_ack_fail(error.to_string()))),\n    }\n}\n\npub fn do_ibc_packet_receive(\n    deps: DepsMut,\n    msg: IbcPacketReceiveMsg,\n) -> Result<IbcReceiveResponse, ContractError> {\n    // The channel this packet is being relayed along on this chain.\n    let channel = msg.packet.dest.channel_id;\n    let msg: IbcExecuteMsg = from_json(&msg.packet.data)?;\n\n    match msg {\n        IbcExecuteMsg::SetName { wallet, name } => {\n            let name = try_set_name(deps, channel, wallet, name)?;\n\n            Ok(IbcReceiveResponse::new()\n                .add_attribute("method", "execute_increment")\n                .add_attribute("name", name)\n                .set_ack(make_ack_success()))\n        }\n    }\n}\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"Sometimes after a failed acknowledgement the contract may want to rollback some data or make note of it for future reference. This contract is simple enough so no rollback or refunds are required. We just return a basic response to the user for both the ack or a timeout. Think of this similarly as a NoOp (no operation)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="src/ibc.rs"',children:'// highlight-start\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn ibc_packet_ack(\n    _deps: DepsMut,\n    _env: Env,\n    _ack: IbcPacketAckMsg,\n) -> Result<IbcBasicResponse, ContractError> {\n    Ok(IbcBasicResponse::new().add_attribute("method", "ibc_packet_ack"))\n}\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn ibc_packet_timeout(\n    _deps: DepsMut,\n    _env: Env,\n    _msg: IbcPacketTimeoutMsg,\n) -> Result<IbcBasicResponse, ContractError> {\n    Ok(IbcBasicResponse::new().add_attribute("method", "ibc_packet_timeout"))\n}\n// highlight-end\n'})}),"\n",(0,a.jsx)(n.h2,{id:"build-contract-from-source",children:"Build Contract From Source"}),"\n",(0,a.jsx)(n.p,{children:"The contract can now be compiled from its source into the .wasm file. This is the binary executable that will be uploaded to the chain."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cargo-run-script optimize\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"start-the-chains-and-connect",children:"Start the chains and connect"}),"\n",(0,a.jsxs)(n.p,{children:["Make sure you are in the ",(0,a.jsx)(n.code,{children:"cwchain"})," directory to begin interacting and uploading the contract to the chain. It is time to start the cosmwasm chain and launch a testnet that connects to itself. The ",(0,a.jsx)(n.code,{children:"self-ibc"})," chain is automatically generated for you on the creation with spawn. It launches 2 of your networks, localchain-1 and localchain-2, and connects them with a relayer operator at startup."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# move back into the cwchain directory\ncd ../\n\n# Install heighliner if you have not already\n# (Easily docker builder tool)\nmake get-heighliner\n\n# Build docker image, set configs, keys, and install binary\n#\n# Error 1 (ignored) codes are okay here if you already have\n# the keys and configs setup. If so you only have to `make local-image`\n# in future runs :)\nmake setup-testnet\n\nlocal-ic start self-ibc\n"})}),"\n",(0,a.jsx)(n.h3,{id:"store-the-contract-on-both-chains",children:"Store the Contract on both chains"}),"\n",(0,a.jsxs)(n.p,{children:["Get the ",(0,a.jsx)(n.a,{href:"https://www.techtarget.com/searchapparchitecture/definition/Remote-Procedure-Call-RPC",children:"RPC "})," interaction addresses for each network from the local-interchain testnet API. Upload the contract source to both chains using the different RPC addresses."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'RPC_1=`curl http://127.0.0.1:8080/info | jq -r .logs.chains[0].rpc_address`\nRPC_2=`curl http://127.0.0.1:8080/info | jq -r .logs.chains[1].rpc_address`\necho "Using RPC_1=$RPC_1 and RPC_2=$RPC_2"\n\nCONTRACT_SOURCE=./nameservice-contract/artifacts/nameservice_contract.wasm\nrolld tx wasm store $CONTRACT_SOURCE --from=acc0 --gas=auto --gas-adjustment=2.0 --yes --node=$RPC_1\n# rolld q wasm list-code --node=$RPC_1\n\nrolld tx wasm store $CONTRACT_SOURCE --from=acc0 --gas=auto --gas-adjustment=2.0 --yes --node=$RPC_2 --chain-id=localchain-2\n# rolld q wasm list-code --node=$RPC_2\n'})}),"\n",(0,a.jsx)(n.h3,{id:"instantiate-our-contract-on-both-chains",children:"Instantiate our Contract on both chains"}),"\n",(0,a.jsx)(n.p,{children:"You can now create your contract from the source on each chain."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"rolld tx wasm instantiate 1 '{}' --no-admin --from=acc0 --label=\"ns-1\" --gas=auto --gas-adjustment=2.0 --yes --node=$RPC_1\nrolld tx wasm instantiate 1 '{}' --no-admin --from=acc0 --label=\"ns-1\" --gas=auto --gas-adjustment=2.0 --yes --node=$RPC_2 --chain-id=localchain-2\n\nrolld q wasm list-contracts-by-creator roll1hj5fveer5cjtn4wd6wstzugjfdxzl0xpg2te87\nrolld q wasm list-contracts-by-creator roll1hj5fveer5cjtn4wd6wstzugjfdxzl0xpg2te87 --node=$RPC_2\n\nNSERVICE_CONTRACT=roll14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sjczpjh\n"})}),"\n",(0,a.jsx)(n.h3,{id:"relayer-connect",children:"Relayer connect"}),"\n",(0,a.jsxs)(n.p,{children:["The relayer must now connect the contracts together and create an IBC connection, link, between them. Use the Local-Interchain helper methods to connect the contracts across the chains. This command will take a second then show a bunch of logs. ",(0,a.jsx)(n.code,{children:"Error context canceled"})," is fine to see. You will verify they were opened in the next step."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# This will take a moment.\n# Connects the 2 contracts together with the IBC relayer\nlocal-ic interact localchain-1 relayer-exec "rly tx link localchain-1_localchain-2 --src-port wasm.${NSERVICE_CONTRACT} --dst-port=wasm.${NSERVICE_CONTRACT} --order unordered --version ns-1"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"verify-channels",children:"Verify channels"}),"\n",(0,a.jsx)(n.p,{children:"Verify the channels were created. Query either with the application binary of the relayer itself. If you see both a channel-0 and channel-1 in your logs, it was a success. If you only see channel-0 re-run the above relayer exec tx link command."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# app binary\nrolld q ibc channel channels\n\n# relayer\nlocal-ic interact localchain-1 relayer-exec "rly q channels localchain-1"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"transaction-interaction",children:"Transaction interaction"}),"\n",(0,a.jsx)(n.p,{children:"Using the ExecuteMsg::SetName method, set a name. This will be transferred to chain 2 behind the scenes. Flushing the relayer will force it to auto pick up pending IBC packets and transfer them across. Not running this may take up to 30 seconds for the relayer to automatically pick it up."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# Set the name from chain 1\nMESSAGE=\'{"set_name":{"channel":"channel-1","name":"myname"}}\'\nrolld tx wasm execute $NSERVICE_CONTRACT "$MESSAGE" --from=acc0 --gas=auto --gas-adjustment=2.0 --yes\n\n# This will take a moment\n# \'account sequence mismatch\' errors are fine.\nlocal-ic interact localchain-1 relayer-exec "rly tx flush"\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"verify-data",children:"Verify data"}),"\n",(0,a.jsxs)(n.p,{children:["After the packet is sent over the network, processed, and acknowledged ",(0,a.jsx)(n.em,{children:"(something that can be done in less than 30 seconds)"}),", you can query the data on chain 2. You can also dump all the contract data out to get HEX and BASE64 encoded data for what the contract state storage looks like."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# query the name on chain 2, from chain 1\nrolld q wasm state smart $NSERVICE_CONTRACT \'{"get_name":{"channel":"channel-1","wallet":"roll1hj5fveer5cjtn4wd6wstzugjfdxzl0xpg2te87"}}\' --node=$RPC_2\n\n# dump contract state from the other chain\nrolld q wasm state all $NSERVICE_CONTRACT --node=$RPC_2\n'})}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"You just build an IBC protocol using cosmwasm! It allowed you to set a name on another network entirely and securely with IBC."}),"\n",(0,a.jsx)(n.h2,{id:"what-you-learned",children:"What you Learned"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Scaffolding an CosmWasm contract"}),"\n",(0,a.jsx)(n.li,{children:"Adding business logic for an IBC request"}),"\n",(0,a.jsx)(n.li,{children:"Implementing IBC in a contract"}),"\n",(0,a.jsx)(n.li,{children:"Connecting two CosmWasm contracts with a custom IBC protocol"}),"\n",(0,a.jsx)(n.li,{children:"Sending a packet from contract A to contract B"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>c});var a=t(7294);const r={},s=a.createContext(r);function c(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);